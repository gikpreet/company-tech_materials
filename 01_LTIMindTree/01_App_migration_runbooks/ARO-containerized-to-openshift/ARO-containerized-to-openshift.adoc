= Managed RedHat OpenShift를 Azure ARO(RedHat OpenShift)로 마이그레이션

== 문서 요약

[cols="1,5", options="header"]
|===
|문서 항목|현재 가치
|문서 제목|FACTORY_Runbook_Azure_RedHat_Openshift_Onprem_Containerized_Apps_To_Openshift
|프로그램|Cloud Acceleration Factory
|마지막으로 수정한 날짜|27-03-2024
|마지막 검토 날짜|10-07-2024
|상태|승인
|문서 설명|이 문서에서는 Devops를 사용하여 온프레미스 컨테이너화된 애플리케이션을 ARO 클러스터로 마이그레이션/구축하는 방법에 대한 지침을 제공합니다.
|===

== 변경 로그

== 목차

<<1. 소개>>

* <<1.1 Azure RedHat OpenShift(ARO)>>
* <<1.2 참조 아키텍처>>

<<2. 역할과 책임>>

<<3. 계획>>

<<4. 전제 조건>>

<<5. 실행>>

* <<5.1 OpenShift 웹 콘솔, DockerFile 전략(수동), DockerHub 이미지 사용 ARO에서 컨테이너화 된 앱의 마이그레이션 단계>>
* <<5.2 ARO에서 컨테이너화됨 앱을 위한 마이그레이션 단계, OpenShift 웹 콘솔 사용, Docklerfile 전략(수동), Azure Container Registry(ACR) 이미지 사용>>
* <<5.3 OpenShift 웹 콘솔을 사용한 ARO 컨테이너화 앱 마이그레이션 단계, S2I(Source-to-Image) 전략(수동)>>
* <<5.4 OpenShift(OC) 명령줄을 사용하여 ARO에서 컨테이너화 된 앱의 마이그레이션 단계>>

<<6. DevOps 파이프라인>>

* <<6.1 OpenShift 내장 Tekton 파이프라인을 사용하여 ARO에서 컨테이너화된 앱의 마이그레이션 단계(수동 트리거)>>
* <<6.2 OpenShift 내장 Tekton 파이프라인을 사용하여 ARO에서 컨테이너화된 앱을 마이그레이션하는 단계(자동 트리거, GitHub 웹훅)>>
* <<6.3 GibHub Actions를 사용하여 ARO에서 컨테이너화 된 앱의 마이그레이션 단계>>
* <<6.4 Azure DevOps를 사용하여 ARO에서 컨테이너화 된 앱의 마이그레이션 단계>>

<<7. 부록>>

== 1. 소개

이 문서에서는 ARO(Azure RedHat OpenShift)에 대한 간략한 소개, ARO 마이그레이션을 위한 필수 구성 요소 및 샘플 컨테이너화 된 애플리케이션을 ARO 클러스터로 마이그레이션하는 자세한 절차/단계를 제공합니다.

=== 1.1 Azure RedHat OpenShift(ARO)

Azure RedHat OpenShift는 Microsoft와 Red Hat이 공동으로 모니터링 및 운영하는 주문성 고가용성 완전 관리형 OpenShift 클러스터를 제공합니다. Kuberneters는 Red Hat OpenShift의 핵심입니다. OpeenShift는 Kubernetees를 보완하는 부가가치 기능을 제공하여 개발자 및 운영자 기능을 크게 개선한 턴키 PaaS(Container Platform as a Service)로 만듭니다.

다음은 ARO의 주요 기능입니다.

* Microsoft와 RedHat이 공동으로 모니터링 및 운영하는 온디맨드 완전 관리형 OpenShift 클러스터
* 쿠버네티스 - PaaS
* 셀프 서비스, 온디맨드 애플리케이션 스택 프로비저닝
* 통합 개발자 도구
* 보안 및 규정 준수
* 확장성 및 가용성
* 하이브리드 및 멀티 클라우드 지원
* Red Hat Enterprise Linux CoreOS(RHCOS)
* 최신 애플리케이션 아키텍처 지원
* 기본 제공 운영자 및 운영자 허브 지원
* 기본 제공 CI/CD 파이프라인

=== 1.2 참조 아키텍처

image:./images/image01.png[]

== 2. 역할과 책임

[cols=5, options="header"]
|===
|과업|책임|책임|상담|정보
|클러스터 생성|고객/파트너|고객/파트너|고객/파트너|Factory
|공유할 평가 보고서|고객/파트너|고객/파트너|고객/파트너|Factory
|분석 보고서 작성|Factory|Factory|고객/Factory|고객/Factory
|애플리케이션 배포|Factory/고객|Factory/고객|Factory/고객|Factory/고객
|===

== 3. 계획

* 클러스터 관리 액세스 보장
* Azure 구독에 대한 Controbutor 역할

== 4. 전제 조건

* 마이그레이션할 애플리케이션의 최종화(Wave 계획)
* Azure 마이그레이션 도구를 실행하여 애플리케이션 평가/수동 검색 - VM에서 실행 중인 모든 애플리케이션, 서비스 및 종속성 식별
* 랜딩 존 Azure Red Hat OpenShift 클러스터 생성
* ARO에서 네트워킹, 저장소, 보안 설정을 구성합니다.
* 클러스터 액세스 및 기여자 역할 액세스
* 매니페스트 파일에 대한 액세스
* 사이트 간 연결성
* 매우 낮은 지연 시간으로 DB 연결이 가능한지 확인하세요.
* 마이그레이션 요구 사항(구성 맵, 스토리지 클래스, 제한, 비밀 등)을 충족하는지 확인하기 위해 마이그레이션 전에 코드 수정을 완료합니다.
* 수집 및 복제/생성할 프로젝트 네임스페이스
* 환경에서 적절한 DNS 확인을 보장합니다.
* Microsoft 참조 아키텍처 다이어그램에 따라 대상 아키텍처 다이어그램을 준비합니다.
* 고객의 승인
* Azure Red Hat OpenShift 4 클러스터에 대한 Microsoft Entra 인증 구성
* 애플리케이션의 성능, 부하 및 리소스 활용도를 평가합니다.
* 스케일링 요구 사항 결정
* Docker를 사용하여 애플리케이션을 컨테이너 이미지로 변환합니다.
* 각 애플리케이션 구성 요소에 대한 Dockerfile을 만듭니다.
* 마이그레이션하기 전에 백업이 제대로 되어 있는지 확인하세요.
* GitHub/Azure DevOps와 같은 도구를 사용하여 CI/CD 파이프라인을 구성합니다. 

== 5. 실행

=== 5.1 OpenShift 웹 콘솔, DockerFile 전략(수동), DockerHub 이미지 사용 ARO에서 컨테이너화 된 앱의 마이그레이션 단계

1. OpenShift 클러스터에 로그인하고 "Administration" 화면으로 이동합닏다.
2. 아직 생성되지 않은 경우 프로젝트 네임스페이스를 만듭니다.
3. "Developer" 관점으로 전환합니다.
+
image:./images/image02.png[]
+
4. 배포에는 여러가지 옵션이 있습니다.
* GIT 리포지토리에서
* 컨테이너 레지스트리
5. 여기서는 "container images" 옵션을 사용하고 있습니다.
6. “Container images” 옵션을 클릭하면 다음 페이지가 열립니다.
+
image:./images/image03.png[]
+
image:./images/image04.png[]
+
7. 레지스트리 이미지 이름(공개 또는 비공개)을 입력하고 모든 세부 정보를 입력하면 이미지가 ARO 워크로드로 배포됩니다. +
참고: 편의를 위해 DockerHub 공개 이미지를 사용했습니다.
8. 워크로드가 배포되면 배포 세부 정보, 로그 및 기타 모니터링 측면을 볼 수 있습니다.
9. 배포된 작업 부하에 대한 자세한 정보를 보려면 "Administration" 측면으로 전환하세요.
+
image:./images/image05.png[]
+
10. 경로 섹션은 배포된 애플리케이션에 외부적으로 접근하는데 도움이 됩니다.
+
image:./images/image06.png[]
+
11. 배포 후 샘플 컨테이너에 배포된 애플리케이션은 다음과 같습니다.
+
image:./images/image07.png[]
+
12. 클러스터 관리 및 기타 관리/인프라 관련 작업을 위해 관리자 모드로 전환하세요. "Workload" 블레이드로 이동하여 Pod, 배포, 시크릿, 구성 맵등을 확인하세요.
+
image:./images/image08.png[]
+
13. "pods" 메뉴에서 새로운 포드를 만들 수 있습니다.
+
image:./images/image09.png[]
+
14. "Create pods"를 클릭하면 아래 YAML이 표시됩니다. 템플릿을 편집하고 포드를 만듭니다.
+
image:./images/image10.png[]

=== 5.2 ARO에서 컨테이너화됨 앱을 위한 마이그레이션 단계, OpenShift 웹 콘솔 사용, Docklerfile 전략(수동), Azure Container Registry(ACR) 이미지 사용

Azure Container Registry(ACR)는 지리적 복제와 같은 엔터프라이즈 기능을 갖춘 프라이빗 Docker 컨테이너 이미지를 저장하는 데 사용할 수 있는 관리형 컨테이너 레지스트리 서비스입니다. ARO 클러스터에서 ARO에 액세스하려면 클러스터가 Kubernetes 시크릿에 Docker 로그인 자격 증명을 저장하여 ACR에 인증해야 합니다.

1. 이 가이드에서는 기본 Azure Container Registry가 있다고 가정합니다. 없는 경우 Azure Portal 또는 Azure CLI 지침을 사용하여 컨테이너 레지스트리를 만드세요. 자세한 내용은 Azure Landing Zone Accelerlator를 참조하세요. +
자세한 내용은 https://github.com/Azure/ARO-Landing-Zone-Accelerator/blob/main/deployment/CLI/09%20appdeployment/app.azcli[ARO-Landing-Zone-Accelerator GitHub 페이지]를 참조하세요.
+
2. OpenShift 클러스터 "Administration" 퍼스펙티브에 로그인하고 새 프로젝트를 생성합니다. 이후 단계에서는 새로 생성된 프로젝트를 사용합니다.
+
image:./images/image11.png[]
+
3. 모든 보안 권한(Full secret)을 얻습니다.
* ARO 클러스터에서 레지스트리에 액세스 하려면 ACR에서 모든 보안 권한(Full secret)이 필요합니다.
* 모든 보안 권한(Full secret)을 얻으려면 Azure Portal이나 Azure CLI를 사용할 수 있습니다.
* Azure Portal을 사용하는 경우 ACR 인스턴스로 이동하여 액세스 키를 선택합니다. docker-username은 컨테이너 레지스트리의 이름이며, docker-password에는 Password 또는 password2를 사용합니다.
+
image:./images/image12.png[]
+
* 대신 Azure CLI를 사용하여 다음 자격 증명을 얻을 수 있습니다.
+
----
az acr credential show -n your registry name
----
+
4. 쿠버네티스 Secret 생성: 이 자격증명을 사용하여 쿠버네티스 시크릿을 생성합니다. ACR 자격 증명을 사용하여 다음 명령을 실행합니다.
+
----
oc create secret docker-registry \
--docker-server=<your registry name>.azurecr.io \
--docker-username=<your registry name> \
--docker-password=******** \
--docker-email=unused \
 acr-secret
----
+
5. 서비스 계정에 시크릿을 연결합니다. 다음으로, Pod가 컨테이너 레지스트리에 접속할 수 있도록 포드에서 사용할 서비스 계정에 시크릿을 연결합니다. 서비스 계정 이름은 Pod에서 사용하는 서비스 계정 이름과 일치해야 합니다. default는 기본 서비스 계정입니다.
+
----
oc secrets link default <pull_secret_name> --for=pull
----
+
6. oc new-app 명령을 사용하여 ACR 이미지를 배포하고 이미지 풀 시크릿을 연결합니다.
+
----
oc new-app --name=sample-aro-dotnet-app-using-acr <your_ registry_name>.azurecr.io/aro-dotnet-sample-app:latest
----
+
7. 현재 서비스는 준비되었지만, 공용 인터넷을 통해 애플리케이션에 접속할 경로는 아직 생성되지 않았습니다. 다음 명령을 사용하여 결로를 생성합니다.
+
----
oc expose svc/aro-dotnet-sample-app
----
+
8. 노출된 경로로 이동하여 앱에 접속합니다.
+
image:./images/image13.png[]
+
image:./images/image14.png[]

=== 5.3 OpenShift 웹 콘솔을 사용한 ARO 컨테이너화 앱 마이그레이션 단계, S2I(Source-to-Image) 전략(수동)

1. 이 접근 방식은 DockerFile을 사용하지 않고도, 즉 앱을 컨테이너화 하지 않고도 작동합니다. 이 전략은 소스를 이해하고 대상 언어와 운영체제를 이해하여 이미지를 만드는 방식으로 작동합니다.
+
image:./images/image15.png[]
+
2. 가져오기 전략을 “Builder image”로 변경합니다.
+
image:./images/image16.png[]
+
image:./images/image17.png[]
+
3. 워크로드를 생성하면 동일한 애플리케이션이 배포되지만 S2I 전략을 사용합니다.
+
image:./images/image18.png[]
+
4. Workload를 클릭하고 생성된 경로를 사용하여 애플리케이션을 탐색합니다.
+
image:./images/image19.png[]
+
5. 애플리케이션이 배포되면 노출된 서비스 경로를 사용하여 애플리케이션에 액세스 할 수 있습니다.
+
image:./images/image20.png[]

=== 5.4 OpenShift(OC) 명령줄을 사용하여 ARO에서 컨테이너화 된 앱의 마이그레이션 단계

1. 새 클러스터가 설치되면 "Help" 아이콘으로 이동하고 "Command line Tools" 옵션으로 이동하면 OpenShift 명령줄 도구를 다운로드 할 수 있습니다.
+
image:./images/image21.png[]
+
2. oc 명령줄 도구를 사용하면 웹 콘솔 단계에 정의된 모든 단계를 수행할 수 있습니다.
+
https://docs.openshift.com/en/container-platform/4.8/cli_reference/openshift_cli/developer-cli-commands.html[OpenShift CLI 개발자 명령 참조 - OpenShift CLI(oc) | CLI 도구 | OpenShift Container Platform 4.8]
3. oc 명령줄 도구를 사용하여 OpenShift 클러스터에 애플리케이션을 배포하는 단계만 살펴보았습니다.
4. 클러스터를 사용하여 oc 명령줄 도구에 연결하려면 "copy login command"를 클릭합니다. 그러면 탭이 열리고 토큰이 표시됩니다.
+
image:./images/image22.png[]
+
5. 호그인 명령을 복사하고 원하는 명령 프롬프트/터미널/PowerShell을 사용하여 클러스터에 연결합니다.
6. oc new-app 명령을 사용하면 워크로드를 클러스터에 배포할 수 있습니다.
+
----
oc new-app openshift/dotnet:8.0~https://github.com/<user_name>/aro-sample-project.git --name=aro-sample-app-cmd --context-dir=aro-sample-project
----
+
image:./images/image23.png[]
+
image:./images/image24.png[]
7. 위 명령어는 샘플앱과 서비스를 배포합니다. 아래 명령어를 사용하여 로그를 확인할 수 있습니다.
+
----
oc new-app openshift/dotnet:8.0~https://github.com/<user_name>/aro-sample-project.git --name=aro-sample-app-cmd --context-dir=aro-sample-project
----
+
image:./images/image25.png[]
8. 현재 서비스는 준비되었지만, 공용 인터넷을 통해 애플리케이션에 접속할 경로가 생성되지 않았습니다. 다음 명령을 사용하여 경로를 생성합니다.
+
----
oc expose svc/aro-sample-app-cmd
----
+
image:./images/image26.png[]
9. 경로가 활성화되면 애플리케이션을 사용할 수 있습니다.
+
image:./images/image27.png[]
+
image:./images/image20.png[]

== 6. DevOps 파이프라인

=== 6.1 OpenShift 내장 Tekton 파이프라인을 사용하여 ARO에서 컨테이너화된 앱의 마이그레이션 단계(수동 트리거)

1. OpehShift에서 Tekton은 OpenShift Pipeline Operator라는 운영자로 제공됩니다. 설치되어 있는지 확인합니다. `Administrator` 뷰를 선택한 후 `Operators` -> `Installed Operators` -> `Searchf or OpenShift Pipelines` 로 이동하여 설치되었는지 확인합니다.
+
image:./images/image28.png[]
2. 새 프로젝트를 만들고 이름을 'cmf-sample-pipeline-dotnet-app'으로 저장합니다.
+
image:./images/image29.png[]
3. Tekton은 모든 파이프라인 호출 시 Persistent volume을 요구합니다. 따라서 프로젝트에 최소 1GB의 영구 볼륨 클레임(PVC)이 있는지 확인해야 합니다. 만약 없다면 `administrator` 뷰를 선택한 후 `Storage` ->  `Persistent Volume Claim` 으로 이동하여 PVC를 생성하고 `my-sample-app-tekton-pvc` 라는 이름을 지정합니다.
+
image:./images/image30.png[]
+
image:./images/image31.png[]
4. 파이프라인을 생성하려면 `Administrator` 보기를 선택하고 `Pipelines` -> `Pipelines` 로 이동한 다음 드롭다운 버튼 `Choose` 를 클릭하고 `Pipeline` 을 선택합니다.
* Pipeline Builder 양식이 열리면 아래오 ㅏ같이 구성합니다.
** `Configure via` 에서 `Pipeline Builder` 라디오 버튼을 클릭합니다.
** `name` 필드에 파이프라인 이름(예: `aro-dotnet-builder-pipeline`)을 입력합니다.
** Parameters에서, `Add Parameter`를 클릭하여 4개의 파라미터를 추가합니다.
*** Name: APP_NAME, 설명: 배포할 애플리케이션의 이름, 기본값: my-sample-dotnet-app
*** Name: APP_GIT_REPO, 설명: 애플리케이션 소스 코드에 대한 GitHub repo URL, 기본값: https://github.com/ <your_GitHub_user>/<your_repo_name>
*** Name: GIT_REVISION, 설명: 배포할 GitHub repo 브랜치 이름, 기본값: master(또는 main)
*** Name: PROJECT_NAME, 설명: 이미지 스트림이 내부 레지스트리에 저장되는 OpenShift 프로젝트, 기본값: <Your_current_Namespace>
* workspace에서, `add workspace`를 클릭하여 새 workspace를 생성하고, `share-workspace`를 입력하고 새 작업 공간을 생성합니다.
+
image:./images/image32.png[]
+
image:./images/image33.png[]
5. Tekton 파이프라인의 기본 정의가 완료되었습니다. 이제 복제-빌드-배포 주기를 위한 파이프라인을 추가해야 합니다.
6. Pipeline 작업 - 아래는 모든 샘플 파이프라인에 대한 샘플 작업입니다.
+
**Task 1: Github에서 소스 코드 검색**
+
Pipeline Builder에서 `Add Task` 를 클릭합니다. `git clone` 을 입력하고 Red Hat에서 작업을 선택한 후 `Add` 버튼을 클릭합니다.
+
image:./images/image34.png[]
+
다음과 같이 구성합니다.
+
----
* Display Name: fetch
* Parameters->url : $(params.APP_GIT_REPO)
* Parameter->revision : $(params.GIT_REVISION)
* Workspaces->output : shared-workspace
----
+
다른 값은 기본값으로 둡니다. 이 작업의 구성을 종료하려면 바깥쪽 아무 곳이나 클릭합니다.
+
image:./images/image35.png[]
+
**Task 2: 소스 코드 빌드**
+
`fetch` 작업에 마우스를 올리고 오른쪽에 있는 파란색 `+` 기호를 클릭합니다. 그러면 다른 작업이 추가됩니다. 새로운 `Add Task` 버튼을 클릭하고 필터에 `S2I dotnet` 을 입력합니다. Red Hat에서 해당 옵션을 선택하고 `Add` 를 클릭합니다. 작업을 다시 클릭하여 작업 구성을 열고 아래와 같이 설정합니다.
+
----
* Display name: build
* Parameters-> Image :

  image-registry openshift-image-registry.svc:5000/$(params.PROJECT_NAME)/$(params.APP_NAME):dev

* Add environment variable - DOTNET_STARTUP_PROJECT=aro-sample-project/aro-sample-project.csproj
* Workspaces->source : shared-workspace
----
+
다른 값은 기본으로 둡니다. 이 작업의 구성을 종료하려면 바깥쪽 아무 곳이나 클릭합니다.
+
image:./images/image36.png[]
+
image:./images/image37.png[]
+
**Task 3: 기존 배포 제거**
+
`build` 작업에 마우스를 올리고 오른쪽에 있는 파란색 `+` 기호를 클릭합니다. 그러면 다른 작업이 추가됩니다. 새로운 `Add Task` 버튼을 클릭하고 필터에 `OpenShift Client` 를 입력합니다. Red Hat에서 옵션을 선택하고 `Add` 를 클릭합니다. `Task` 를 다시 클릭하여 작업 구성을 열고 아래와 같이 설정합니다.
+
----
* Display Name: cleanup-old-deployment
* Parameters->Script :

  oc delete all -l app=$(params.APP_NAME)
----
+
image:./images/image38.png[]
+
다른 값은 기본으로 둡니다. 이 작업의 구성을 종료하려면 바깥쪽 아무 곳이나 클릭합니다.
+
**Task 4: 빌드된 코드 배포**
+
`cleanup-old-deployment` 작업에 마우스를 올리고 오른쪽에 있는 파란색 `+` 기호를 클릭합니다. 그러면 다른 작업에 추가됩니다. 새로 생성된 'Add Task' 버튼을 클릭하고 필터에 `OpenShift Client` 를 입력하세요. Red Hat에서 해당 옵션을 선택하고 `Add` 버튼을 클릭합니다. `Task` 를 다시 클릭하여 작업 구성을 열고 아래와 같이 설정하세요.
+
----
* Display Name: deploy-code
* Parameters->SCRIPT

  oc new-app --name $(params.APP_NAME) --as-deployment-config image-registry.openshift-image-registry.svc:5000/$(params.PROJECT_NAME)/$(params.APP_NAME):dev --context-dir=aro-sample-project

----
+
다른 값은 기본으로 둡니다. 이 작업의 구성을 종료하려면 바깥쪽 아무 곳이나 클릭합니다.
+
image:./images/image39.png[]
+
**Task 5: 경로상의 서비스 노출**
+
`deploy` 작업에 마우스를 올리고 오른쪽에 있는 파란색 `+` 기호를 클릭합니다. 그러면 다른 작업이 추가됩니다. 새로운 `Add Task` 버튼을 클릭하고 필터에 `OpenShift Client` 를 입력합니다. Red Hat에서 옵션을 선택하고 `Add` 를 클릭합니다. 작업을 다시 클릭하여 작업 구성을 열고 아래와 같이 설정합니다.
+
----
* Display Name: expose-service
* Parameters->SCRIPT:

  oc expose svc $(params.APP_NAME)
----
+
다른 값은 기본 값으로 둡니다. 이 작업의 구성을 종료하려면 바깥쪽 아무 곳이나 클릭합니다.
+
image:./images/image40.png[]
+
image:./images/image41.png[]
+
**Task 6: 배포 확인**
+
`expose-service` 작업에 마우스를 올리고 오른쪽에 있는 파란색 `+` 기호를 클릭합니다. 그러면 다른 작업이 추가됩니다. 새로 생성된 `Add Task` 버튼을 클릭하고 필터에 `OpenShift Client` 를 입력합니다. Red Hat에서 해당 옵션을 선택하고 `Add` 를 클릭합니다. 작업을 다시 클릭하여 작업 구성을 열고 아래와 같이 설정합니다.
+
----
* Display Name: verify-rollout
* Parameters->SCRIPT :

  oc rollout status dc/$(params.APP_NAME)
----
+
다른 값은 기본 값으로 둡니다. 이 작업의 구성을 종료하려면 바깥쪽 아무 곳이나 클릭합니다. 파이프라인을 생성하려면 파란색 'Create' 버튼을 클릭합니다.
+
image:./images/image42.png[]
+
GitHub 저장소에 변경 사항을 커밋하고 파이프라인을 실행하여 변경 사항을 확인합니다.
+
image:./images/image43.png[]

7. 파이프라인을 수동으로 트리거합니다.
8. `Administration` 보기로 이동하여 파이프라인으로 이동합니다. 점 세개로 표시된 버거 메뉴를 선택하고 `Start` 를 클릭합니다.
+
image:./images/image44.png[]
+
9. 파라미터를 검토하고 파이프라인을 실행할 PVC(Persistent Volume Claim)를 선택합니다. `Start` 를 클릭합니다.
+
image:./images/image45.png[]
+
10. workload, Pod, Service 및 routes를 검토합니다. route path를 클릭하여 애플리케이션에 액세스합니다.
+
image:./images/image46.png[]
+
image:./images/image47.png[]

=== 6.2 OpenShift 내장 Tekton 파이프라인을 사용하여 ARO에서 컨테이너화된 앱을 마이그레이션하는 단계(자동 트리거, GitHub 웹훅)

1. 파이프라인과 결합된 트리거를 사용하면 파이프라인을 연결하여 외부 GitHub 이벤트(푸시 이벤트, 풀 리퀘스트 등)에 응답할 수 있습니다.
2. 이를 위한 전제 조건은 웹훅을 사용하기 위해 프로젝트에 Trigger Template, TriggerBinding, EventListener를 정의해야 한다는 것입니다.
3. 웹훅과 연결될 GitHub-secret을 생성합니다. `webhook-secret.yaml` 파일을 생성합니다.
+
----
webhook-secret.yml:
-------------------

apiVersion: v1
kind: Secret
metadata:
name: webhook-secret
namespace: cmf-pipeline-project
stringData:
secretToken: sample-secret
----
+ 
4. Secret을 적용합니다.
+
----
oc apply -f webhook-secret.yaml
----
5. 이제 TriggerTemplte을 정의합니다. TriggerTemplate은 템플릿 리소스 내 어디에서나 대체될 수 있는 파라미터를 가진 리소스입니다. `github-template.yaml` 파일을 생성합니다.
+
----
github-template.yml:
--------------------

apiVersion: triggers.tekton.dev/v1alpha1
kind: TriggerTemplate
metadata:
name: github-template
spec:
params:
    - name: gitrevision
    description: The git revision
    default: main
    - name: gitrepositoryurl
    description: The git repository URL
resourcetemplates:
    - apiVersion: tekton.dev/v1beta1
    kind: PipelineRun
    metadata:
        generateName: github-pipelinerun-
    spec:
        pipelineRef:
        name: aro-dotnet-builder-pipeline
        workspaces:
        - name: shared-workspace
            persistentVolumeClaim:
            claimName: my-sample-app-tekton-pvc
        params:
        - name: gitrevision
            value: $(params.gitrevision)
        - name: gitrepositoryurl
            value: $(params.gitrepositoryurl)
----
+
6. 템플랫을 적용합니다.
+
----
oc apply -f github-template.yaml
----
+
7. 다음 단계는 이벤트에서 필드를 캡처하고 파라미트로 저장한 다음 이벤트가 발생할 때 마다 TriggerTemplate에서 이를 바꿀수 있는 TriggerBinding을 만드는 것입니다. +
`github-binding.yaml` 파일을 만들고 동일하게 적용합니다.
+
----
github-binding.yaml:
-------------------

apiVersion: triggers.tekton.dev/v1alpha1
kind: TriggerBinding
metadata:
name: github-binding
spec:
params:
    - name: gitrevision
    value: $(body.head_commit.id)
    - name: gitrepositoryurl
    value: $(body.repository.clone_url)
----
+
----
oc apply -f github-binding.yaml        
----
+
8. 마지막으로 EventListener를 만듭니다. 이 컴포넌트는 Service를 설정하고 이벤트를 수신합니다. 또한 TriggerTemplate을 TriggerBinding에 연결하여 주소 지정 가능한 엔드포인트(이벤트 싱크)로 전달합니다.
+
`github-listener.yaml` 파일을 만들고 동일하게 적용합니다.
+
----
github-listener.yaml:
--------------------

apiVersion: triggers.tekton.dev/v1alpha1
kind: EventListener
metadata:
name: github-listener
spec:
serviceAccountName: pipeline
triggers:
    - name: github-trigger
    interceptors:
        - ref:
            name: "github"
        params:
            - name: secretRef
            value:
                secretKey: secretToken
                secretName: webhook-secret
    bindings:
        - ref: github-binding
    template:
        ref: github-template
----
+
----
oc apply -f github-listener.yaml
----
+
9. 아래 명령을 실행하여 eventListener 서비스를 경로로 노출합니다.
+
----
oc expose svc el-github-listener
----
+
10. 다음 단계는 GitHub 저장소에서 웹훅을 구성하는 것입니다.
* GitHub 저장소에서:
** `Settings` -> 'WebHooks' 로 이동합니다.
** `Add webhook` 을 클릭합니다.
** `oc expose` 명령으로 생성된 경로 URL로 페이로드 URL을 설정합니다.
** `Content type` 을 `application/Json` 으로 설정합니다.
** `Secret` 아래에 비밀 토큰을 추가합니다. (webhook-secret.yaml에서 사용한 토큰과 동일)
** webhook을 트리거해야 하는 이벤트를 선택합니다. (예: 푸시 이벤트)
** `Add webhook` 을 클릭합니다.
+
image:./images/image48.png[]
+
11. 설정을 테스트하고 Github 저장소에 변경 사항을 푸시하면 모든 푸시 이벤트에 대해 파이프라인이 자동으로 시작됩니다.
+
image:./images/image49.png[]

=== 6.3 GibHub Actions를 사용하여 ARO에서 컨테이너화 된 앱의 마이그레이션 단계

GitHub Actions는 모든 GitHub 저장소에서 사용할 수 있는 이벤트 기반 자동화 작업입니다. 이벤트는 작업을 포함하는 워크플로를 자동으로 트리거합니다. 그러면 작업은 단계를 사용하여 작업 실행 순서를 제어합니다. 이러한 작업은 소프트웨어 빌드, 테스트 및 배포를 자동화하는 명령입니다. 이 장에서는 샘플 .NET Core 백엔드 컨테이너 이미지를 빌드하고 docker-hub 레지스트리에 푸시하기 위한 GitHub Action을 추가합니다. +
참고: GitHub Azure 컨테이너 레지스트리 등 다른 컨테이너 레지스트리도 사용할 수 있습니다.

==== 1) OpenShift 프로젝트 생성

`Administrator` 관점으로 이동하여 새 프로젝트를 만듭니다.

image:./images/image50.png[]

==== 2) GitHub Action 구성

GitHub Actions 워크플로는 환경으로 실행되며, 해당 환경의 보호 규칙과 비밀을 사용하기 위해 환경을 참조할 수 있습니다. 이 단계에서는 development라는 이름의 새 환경을 추가합니다. 이전에 GibHub에서 포크한 `aro-sample-project` 저장소에서 오른쪽 상단 메뉴로 이동하여 설정을 클릭합니다. 그런 다음 왼쪽 메뉴에서 `Environment` 를 클릭하고 오른쪽에서 `new environment` 를 클릭합니다.

image:./images/image51.png[]

==== 3) GitHub 환경 설정

다음 창에서 이름에 사용할 GitHub 환경의 이름을 삽입합니다.

Action: **development**

`Configure environment` 를 클릭하여 환경 구성을 생성합니다.

image:./images/image52.png[]

==== 4) Github Secret

방금 생성한 GitHub 환경 development의 결과 화면에서 새로 생성된 환경의 모든 세부 정볼르 확인할 수 있습니다. 섹션 하단의 `Environment Secret` 로 이동하고 'Add Secret' 를 클릭하여 새 Secret을 추가합니다.

이제 GitHub Action에서 OpenShift 클러스터에 연결하는데 사용할 두 개의 Secret을 구성합니다.

* OPENSHIFT_SERVER: The OpenShift API server
* OPENSHIFT_TOKEN: The authentication token to connect with
* IMAGE_REGISTRY_PASSWORD: Docker hub token

image:./images/image53.png[]

==== 5) Action 추가

이제 GitHub Action과 OpenShift를 사용하여 자동화를 시작할 준비가 되었습니다. GitHub Action의 워크플로와 작업은 필요한 모든 단계가 포함된 YAML 파일로 정의됩니다.

1. GitHub에서 `sample-dotnet-application` 백엔드 빌드를 트리거하는데 사용되는 다음 워크플로를 검토합니다.
2. GitHub에서 OpenShift 스타터 템플릿을 선택하고 워크플로를 트리거하기 위한 단계와 변수를 편집합니다.
+
image:./images/image54.png[]
+
또는, 
+
image:./images/image55.png[]
+
3. main.yml 예제 새 파일의 이름을 openshift.yml로 변경합니다.
4. 이전에 복사한 YAML 내용을 새 파일 편집 아래의 코드 텍스트 상자에 붙여넣어 예제 내용을 바꿉니다.
5. `Start Commit` 을 클릭합니다. Commnt 제목을 입력하고 `new file commit` 을 클릭합니다.
6. 참고용으로 시작 템플릿을 사용하세요.
+
----
name: OpenShift

env:
# 🖊️ EDIT your repository secrets to log into your OpenShift cluster and set up the context.
# See https://github.com/redhat-actions/oc-login#readme for how to retrieve these values.
# To get a permanent token, refer to https://github.com/redhat-actions/oc-login/wiki/Using-a-Service-Account-for-GitHub-Actions
OPENSHIFT_SERVER: ${{ secrets.OPENSHIFT_SERVER }}
OPENSHIFT_TOKEN: ${{ secrets.OPENSHIFT_TOKEN }}
# 🖊️ EDIT to set the kube context's namespace after login. Leave blank to use your user's default namespace.
OPENSHIFT_NAMESPACE: "cmf-deployment-github-actions"

# 🖊️ EDIT to set a name for your OpenShift app, or a default one will be generated below.
APP_NAME: "aro-sample-github-action-app"

# 🖊️ EDIT with the port your application should be accessible on.
# If the container image exposes *exactly one* port, this can be left blank.
# Refer to the 'port' input of https://github.com/redhat-actions/oc-new-app
APP_PORT: "8080"

# 🖊️ EDIT to change the image registry settings.
# Registries such as GHCR, Quay.io, and Docker Hub are supported.
IMAGE_REGISTRY: docker.io/{username}
IMAGE_REGISTRY_USER: {username}
IMAGE_REGISTRY_PASSWORD: ${{ secrets.IMAGE_REGISTRY_PASSWORD }}

# 🖊️ EDIT to specify custom tags for the container image, or default tags will be generated below.
IMAGE_TAGS: "latest"

on:
# https://docs.github.com/en/actions/reference/events-that-trigger-workflows
workflow_dispatch:
push:
    # Edit to the branch(es) you want to build and deploy on each push.
    branches: [ "main" ]

jobs:
# 🖊️ EDIT if you want to run vulnerability check on your project before deploying
# the application. Please uncomment the below CRDA scan job and configure to run it in
# your workflow. For details about CRDA action visit https://github.com/redhat-actions/crda/blob/main/README.md
#
# TODO: Make sure to add 'CRDA Scan' starter workflow from the 'Actions' tab.
# For guide on adding new starter workflow visit https://docs.github.com/en/github-ae@latest/actions/using-workflows/using-starter-workflows

openshift-ci-cd:
    # 🖊️ Uncomment this if you are using CRDA scan step above
    # needs: crda-scan
    name: Build and deploy to OpenShift
    runs-on: ubuntu-22.04
    environment: development

    outputs:
    ROUTE: ${{ steps.deploy-and-expose.outputs.route }}
    SELECTOR: ${{ steps.deploy-and-expose.outputs.selector }}

    steps:
    - name: Check for required secrets
    uses: actions/github-script@v6
    with:
        script: |
        const secrets = {
            OPENSHIFT_SERVER: `${{ secrets.OPENSHIFT_SERVER }}`,
            OPENSHIFT_TOKEN: `${{ secrets.OPENSHIFT_TOKEN }}`,
        };

        const GHCR = "ghcr.io";
        if (`${{ env.IMAGE_REGISTRY }}`.startsWith(GHCR)) {
            core.info(`Image registry is ${GHCR} - no registry password required`);
        }
        else {
            core.info("A registry password is required");
            secrets["IMAGE_REGISTRY_PASSWORD"] = `${{ secrets.IMAGE_REGISTRY_PASSWORD }}`;
        }

        const missingSecrets = Object.entries(secrets).filter(([ name, value ]) => {
            if (value.length === 0) {
            core.error(`Secret "${name}" is not set`);
            return true;
            }
            core.info(`✔️ Secret "${name}" is set`);
            return false;
        });

        if (missingSecrets.length > 0) {
            core.setFailed(`❌ At least one required secret is not set in the repository. \n` +
            "You can add it using:\n" +
            "GitHub UI: https://docs.github.com/en/actions/reference/encrypted-secrets#creating-encrypted-secrets-for-a-repository \n" +
            "GitHub CLI: https://cli.github.com/manual/gh_secret_set \n" +
            "Also, refer to https://github.com/redhat-actions/oc-login#getting-started-with-the-action-or-see-example");
        }
        else {
            core.info(`✅ All the required secrets are set`);
        }

    - name: Check out repository
    uses: actions/checkout@v4

    - name: Set up .NET
    uses: actions/setup-dotnet@v2
    with:
        dotnet-version: '8.0.x'  

    - name: Determine app name
    if: env.APP_NAME == ''
    run: |
        echo "APP_NAME=$(basename $PWD)" | tee -a $GITHUB_ENV

    - name: Determine image tags
    if: env.IMAGE_TAGS == ''
    run: |
        echo "IMAGE_TAGS=latest ${GITHUB_SHA::12}" | tee -a $GITHUB_ENV

    # https://github.com/redhat-actions/buildah-build#readme
    - name: Build from Dockerfile
    id: build-image
    uses: redhat-actions/buildah-build@v2
    with:
        image: ${{ env.APP_NAME }}
        tags: ${{ env.IMAGE_TAGS }}

        # If you don't have a Dockerfile/Containerfile, refer to https://github.com/redhat-actions/buildah-build#scratch-build-inputs
        # Or, perform a source-to-image build using https://github.com/redhat-actions/s2i-build
        # Otherwise, point this to your Dockerfile/Containerfile relative to the repository root.
        dockerfiles: |
        ./Dockerfile

    # https://github.com/redhat-actions/push-to-registry#readme
    - name: Push to registry
    id: push-image
    uses: redhat-actions/push-to-registry@v2
    with:
        image: ${{ steps.build-image.outputs.image }}
        tags: ${{ steps.build-image.outputs.tags }}
        registry: ${{ env.IMAGE_REGISTRY }}
        username: ${{ env.IMAGE_REGISTRY_USER }}
        password: ${{ env.IMAGE_REGISTRY_PASSWORD }}

    # The path the image was pushed to is now stored in ${{ steps.push-image.outputs.registry-path }}

    - name: Install oc
    uses: redhat-actions/openshift-tools-installer@v1
    with:
        oc: 4

    # https://github.com/redhat-actions/oc-login#readme
    - name: Log in to OpenShift
    uses: redhat-actions/oc-login@v1
    with:
        openshift_server_url: ${{ env.OPENSHIFT_SERVER }}
        openshift_token: ${{ env.OPENSHIFT_TOKEN }}
        insecure_skip_tls_verify: true
        namespace: ${{ env.OPENSHIFT_NAMESPACE }}

    # This step should create a deployment, service, and route to run your app and expose it to the internet.
    # https://github.com/redhat-actions/oc-new-app#readme
    - name: Create and expose app
    id: deploy-and-expose
    uses: redhat-actions/oc-new-app@v1
    with:
        app_name: ${{ env.APP_NAME }}
        image: ${{ steps.push-image.outputs.registry-path }}
        namespace: ${{ env.OPENSHIFT_NAMESPACE }}
        port: ${{ env.APP_PORT }}

    - name: Print application URL
    env:
        ROUTE: ${{ steps.deploy-and-expose.outputs.route }}
        SELECTOR: ${{ steps.deploy-and-expose.outputs.selector }}
    run: |
        [[ -n ${{ env.ROUTE }} ]] || (echo "Determining application route failed in previous step"; exit 1)
        echo
        echo "======================== Your application is available at: ========================"
        echo ${{ env.ROUTE }}
        echo "==================================================================================="
        echo
        echo "Your app can be taken down with: \"oc delete all --selector='${{ env.SELECTOR }}'\""
----
+
참고: 이 템플릿은 .NET 앱 전용입니다. 애플리케이션 유형에 따라 템플릿을 선택해주세요.
+
image:./images/image56.png[]
+
7. 변경 사항을 커밋하지마자 해당 작업이 시작되고 애플리케이션이 배포됩니다.
+
image:./images/image57.png[]
+
image:./images/image58.png[]

=== 6.4 Azure DevOps를 사용하여 ARO에서 컨테이너화 된 앱의 마이그레이션 단계

Microsoft Azure DevOps를 사용하여 Red Hat OpenShift에 애플리케이션을 배포하는 파이프라인을 설정하는 모든 단계를 살펴봅니다.

image:./images/image59.png[]

**필수 조건**

* GitHub 계정
* Azure 구독
* Red Hat OpenShift 클러스터
* Azure DevOps에 대한 액세스

1. ADO 조직에서 새 프로젝트를 만듭니다.
+
image:./images/image60.png[]
+
2. OpenShift 확장 프로그램 설치
+
마켓플레이스[여기] ( https://marketplace.visualstudio.com/items?itemName=redhat.openshift-vsts )에서 무료로 받기를 클릭하고 조직에 설치합니다.
+
image:./images/image61.png[]
+
image:./images/image62.png[]
+
3. 서비스 연결 생성
+
Microsoft Azure DevOps를 OpenShift 클러스터에 연결하려면 OpenShift 서비스 연결을 구성해야 합니다.
+
. Click on Project settings를 클릭합니다.
. Service Connections를 선택합니다.
. OpenShift를 선택합니다.
+
image:./images/image63.png[]
+
원하는 인증 방식(Basic, Token or No authentication)을 선택합니다. 기존 OpenShift 클러스터에서 서버 URL과 API 토큰을 가져옵니다.
+
image:./images/image64.png[]
+
4. 파이프라인 생성:
+
파이프라인으로 이동합니다.
+
image:./images/image65.png[]
+
`Create Pipeline` 을 클릭합니다. 코드가 GitHub에 있으므로 GitHub 옵션을 사용합니다.
+
image:./images/image66.png[]
+
그런 다음 Azure Pipelines를 승인합니다. 리포지토리를 선택하라는 메시지가 표시됩니다.
+
image:./images/image67.png[]
+
image:./images/image68.png[]
+
GitHub에 대한 연결이 승인되면 파이프라인을 구성하고 Starter 파이프라인을 선택합니다.
+
image:./images/image69.png[]
+
`Show assistant` 를 클릭하고 `Execute oc` 를 선택하여 OC 명령을 실행합니다.
+
image:./images/image70.png[]
+
image:./images/image71.png[]
+
그런 다음 `Add` 를 클릭합니다. 다음 명령에 대해서도 같은 단계를 반복합니다. 참고용으로 첨부된 템플릿을 확인하세요.
+
----
        Starter Template:
        -----------------

        trigger:
        - main

        pool:
          vmImage: ubuntu-latest

        steps:

        - task: oc-cmd@3
          inputs:
            connectionType: 'OpenShift Connection Service'
            openshiftService: 'openshift-ado-service-connection'
            cmd: 'oc project ado-pipeline-project'
          displayName: 'Select Project'
        - task: oc-cmd@3
          inputs:
            connectionType: 'OpenShift Connection Service'
            openshiftService: 'openshift-ado-service-connection'
            cmd: 'oc delete buildconfig ado-openshift-app'
          displayName: 'Cleanup old Build Config'
        - task: oc-cmd@3
          inputs:
            connectionType: 'OpenShift Connection Service'
            openshiftService: 'openshift-ado-service-connection'
            cmd: 'oc delete deployment ado-openshift-app'
          displayName: 'Cleanup old Deployment'
        - task: oc-cmd@3
          inputs:
            connectionType: 'OpenShift Connection Service'
            openshiftService: 'openshift-ado-service-connection'
            cmd: 'oc delete service ado-openshift-app'
          displayName: 'Cleanup old Service'

        - task: oc-cmd@3
          inputs:
            connectionType: 'OpenShift Connection Service'
            openshiftService: 'openshift-ado-service-connection'
            cmd: 'oc delete route ado-openshift-app'
          displayName: 'Cleanup old Route'
        - task: oc-cmd@3
          inputs:
            connectionType: 'OpenShift Connection Service'
            openshiftService: 'openshift-ado-service-connection'
            cmd: 'oc delete imagestream ado-openshift-app -n ado-pipeline-project'
          displayName: 'Cleanup old Image Stream'  
        - task: oc-cmd@3
          inputs:
            connectionType: 'OpenShift Connection Service'
            openshiftService: 'openshift-ado-service-connection'
            cmd: 'oc new-app openshift/dotnet:7.0-ubi8~https://github.com/panchsan/ado-pipeline-openshift.git --name=ado-openshift-app --context-dir=MyDotnetOpenshiftApp'
          displayName: 'Start New Deployment'
        - task: oc-cmd@3
          inputs:
            connectionType: 'OpenShift Connection Service'
            openshiftService: 'openshift-ado-service-connection'
            cmd: 'oc expose svc/ado-openshift-app'
          displayName: 'Expose service'
        - task: oc-cmd@3
          inputs:
            connectionType: 'OpenShift Connection Service'
            openshiftService: 'openshift-ado-service-connection'
            cmd: 'oc logs -f buildconfig/ado-openshift-app'
          displayName: 'Get Build Logs'
        - task: oc-cmd@3
          inputs:
            connectionType: 'OpenShift Connection Service'
            openshiftService: 'openshift-ado-service-connection'
            cmd: 'oc status'
          displayName: 'Verify Rollout'
----
+
파이프라인을 저장하고 실행합니다.
+
image:./images/image72.png[]
+
해당 작업에 접근하여 확인합니다.
+
image:./images/image73.png[]
+
5. 배포 확인
+
OpenShift 클러스터에 로그인하고 OpenShift 클러스터에서 배포를 확인합니다.
+
image:./images/image74.png[]
+
image:./images/image75.png[]

== 7. 부록

* https://docs.openshift.com/en/container-platform/4.7/cli_reference/openshift_cli/getting-started-cli.html[OpenShift CLI 시작하기 - OpenShift CLI(oc) | CLI 도구 | OpenShift Container Platform 4.7]
* https://docs.openshift.com/en/container-platform/4.9/cicd/pipelines/using-tekton-hub-with-openshift-pipelines.html[OpenShift 파이프라인과 함께 Tekton Hub 사용 - 파이프라인 | CI/CD | OpenShift 컨테이너 플랫폼 4.9]
* https://www.redhat.com/en/blog/deploying-to-openshift-using-github-actions[GitHub Actions를 사용하여 OpenShift에 배포(redhat.com)]
* https://github.com/Azure/ARO-Landing-Zone-Accelerator/blob/main/deployment/CLI/09%20appdeployment/app.azcli[ARO-Landing-Zone-Accelerator/deployment/CLI/09 appdeployment/app.azcli at main · Azure/ARO-Landing-Zone-Accelerator (github.com)]